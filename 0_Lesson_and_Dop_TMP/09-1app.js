// Node.js #9 Создание базового роутинга (Create Base Routing)
// 09-1app.js

const http = require("http");
const fs = require("fs");
const path = require("path");

const PORT = 3000;

const server = http.createServer((req, res) => {
  console.log("Server request");

  res.setHeader("Content-Type", "text/html"); //поскольку работать будем с разметкой, то Content-Type, определяем как html
  const createPath = (page) => path.resolve(__dirname, "views", `${page}.html`); // создаем функцию createPath
  // поскольку основная задача это построение пути до файла, её мы можем инкапсулировать. Для этого внутри функции воспользуемся path.resolve. Первым арнументом передадим __dirname (при определении пути до файла применяется явное определение с помощью этого глобального объекта, для получения пути до исполняемого скрипта), дальше указываем апаку 'views', и имя файла `${page}.html`. На выходе функции получаем простую строку. Модуль Path кроссплатформенный, т.к. различает использование \ и / и передает нужное значение

  let basePath = "";

  // создаем условие swith - case, принимать оно будет url-адрес запроса,а дальше в каждом case, в переменную Path на основании url-адреса, мы будем присваивать путь до страницы

  switch (req.url) {
    case "/":
    case "/home": // пример множественных путей для одной страницы
    case "/index.html": // пример множественных путей для одной страницы
      basePath = createPath("index"); // вызывает страницу index
      res.statusCode = 200; // создаем успешный код возврата - обращаемся к объекту ответа и определяем его статус-код. Фактически это можно не делать, т.к. если сервер что-то возвращает, то статус-код присваивается автоматичски
      break;

    // Создание ре-директа.
    // добавим логику: если пользователь переходит на старый роут, он автоматически будет перенаправлен на актуальный. Для этого используется статус-код и метод .setHeader:

    case "/about-us": // Создали case. предположим это старый адрес контактов
      res.statusCode = 301; // ставим статус-код = 301, для того, чтобы дать понять, что ре-директ котролируемый
      res.setHeader("Location", "/contacts"); // устанавливаем хедер ответа, в котором определяем Location и присваиваем значение пути на который должден произойти ре-директ
      res.end(); // поскольку в этом случае пути до файла мы не создаем, нам нужно отправить сформированный отет с помощью res.end();
      break;
    case "/contacts":
      basePath = createPath("contacts");
      res.statusCode = 200;
      break;
    default:
      basePath = createPath("error"); // вызывает страницу ошибки, т.е. если пользователь введет не существующий путь, то он автоматически будет отправлен на страницу ошибки
      res.statusCode = 404; // ввели информацию о клиентской ошибке, а именно - пользователь ввел некорректные данные и получил ошибку о несуществующей странице
      break;
  }

  fs.readFile(basePath, (err, data) => {
    if (err) {
      // кейс обработки ошибки: если что-то пойдет не так, мы получим в терминале сообщение об ошибке и остановим чтение файла
      console.log(err);
      res.statusCode = 500; // т.к. ошибка происходит при парсинге файла, следовательно это какая-то внутренняя серверная ошибка
      res.end(); // записывает и в кейсе ошибки и ответа
    } else {
      // в случае успеха в ответ записываем прочитанную разметку и возвращаем ее браузеру
      res.write(data);
      res.end();
    }
  }); // далее, используя файловую систему нам нужно прочитать файл index.html и после прочтения, внутри callback-функции, вернуть его в ответ
});

server.listen(PORT, "localhost", (error) => {
  error ? console.log(error) : console.log(`listening port ${PORT}`);
});
